import{c as e,o as t,g as a}from"./vendor.9944df43.js";const n={class:"markdown-body"},s=a('<h1>Signature spec</h1><h2>Introduction</h2><p>A Univrse Signature is a structure attached to an Envelope, containing a set of headers and a cryptographic signature (or MAC). An Envelope may contain one or multiple Signature structures.</p><p>The Signature structure headers must contain an <code>alg</code> header and may contain a <code>kid</code> header, to help other parties understand what key and algorithm was used to generate the signature or MAC. Once understood, the observing party can verify the signature contained in the structure.</p><h2>Structure</h2><p>A Univrse Signature described using Concise Data Definition Language:</p><pre><code class="language-elixir">Signature <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token attr-name">header:</span> Header<span class="token punctuation">,</span>\n  <span class="token attr-name">signature:</span> bytes\n<span class="token punctuation">]</span>\n\nHeader <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">alg:</span> text<span class="token punctuation">,</span>\n  ? <span class="token attr-name">kid:</span> text<span class="token punctuation">,</span>\n  <span class="token operator">*</span> text <span class="token operator">=&gt;</span> any\n<span class="token punctuation">}</span>\n</code></pre><h2>Headers</h2><p>A Univrse Signature may contain any of the following headers. It may also contain any other arbitrary headers.</p><table><thead><tr><th>Header</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td><code>alg</code></td><td>Signature algorithm</td><td>âœ…</td></tr><tr><td><code>kid</code></td><td>Key ID</td><td></td></tr></tbody></table><h2>Algorithms</h2><p>The following algorithms can be used with Univrse Signatures.</p><table><thead><tr><th>Algorithm</th><th>Description</th><th>Key type</th></tr></thead><tbody><tr><td><code>HS256</code></td><td>HMAC using SHA-256</td><td><code>oct</code></td></tr><tr><td><code>HS512</code></td><td>HMAC using SHA-512</td><td><code>oct</code></td></tr><tr><td><code>ES256K</code></td><td>ECDSA signature on secp256k1 curve</td><td><code>EC</code></td></tr><tr><td><code>ES256K-BSM</code></td><td>Bitcoin Signed Message algorithm</td><td><code>EC</code></td></tr></tbody></table><p>For all algorithms, the signing input consists of the Envelope headers and payload, serialised as a CBOR-encoded binary.</p><h3><code>HS256</code> - HMAC using SHA-256</h3><p>A <code>HMAC SHA-256</code> MAC is generated per <a href="https://datatracker.ietf.org/doc/html/rfc2104">RFC 2104</a>, using <code>SHA-256</code> as the hash algorithm and using an <code>oct</code> key 256 bits long.</p><p>The result is a 32 byte signature. The signature is validated by generating a MAC as above using the same key, and comparing the result with the Univrse Signature value.</p><h3><code>HS512</code> - HMAC using SHA-512</h3><p>A <code>HMAC SHA-512</code> MAC is generated per <a href="https://datatracker.ietf.org/doc/html/rfc2104">RFC 2104</a>, using <code>SHA-512</code> as the hash algorithm and using an <code>oct</code> key 512 bits long.</p><p>The result is a 64 byte signature. The signature is validated by generating a MAC as above using the same key, and comparing the result with the Univrse Signature value.</p><h3><code>ES256K</code> - ECDSA signature on secp256k1 curve</h3><p>A signature is generated by using the <code>SHA-256</code> hash algorithm on the signing input, and creating an ECDSA signature on the <code>secp256k1</code> curve using an <code>EC</code> key. Implementations should use a deterministic algorithm to generate the ECDSA nonce, k, such as the algorithm defined in <a href="https://datatracker.ietf.org/doc/html/rfc6979">RFC6979</a>.</p><p>The result is a 65 byte compact signature. The signature can be verified using the same <code>EC</code> public key.</p><h3><code>ES256K-BSM</code> - Bitcoin Signed Message algorithm</h3><p>This algorithm is similar to <code>ES256K</code>, with the following differences: The signing input is first prefixed with the string <code>&quot;Bitcoin Signed Message:\\n&quot;</code>, and then hashed TWICE using the <code>SHA-256</code> algorithm.</p><p>This algorithm is commonly used in the SDKs of popular web wallets such as Money Button and Relay.</p>',26),o={expose:[],setup:a=>(a,o)=>(t(),e("div",n,[s]))};export default o;
